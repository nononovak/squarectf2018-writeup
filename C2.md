# C2: flipping bits

Link: [https://squarectf.com/2018/flipping_bits.html](https://squarectf.com/2018/flipping_bits.html)

This challenge [provided](./files/flipping_bits.txt) two messages RSA encoded with different public exponents and the same modulus.

## Solution

Using the same modulus with different exponents leaves RSA open to a "Common Modulus Attack" described in many places (like [here](https://math.boisestate.edu/~liljanab/ISAS/course_materials/AttacksRSA.pdf)). As described in the link, this can be solved by performing the extended Euclidean algorithm on the two exponents and using the result in a mathematical operation.

The extended GCD can be found using [wolfram alpha](https://www.wolframalpha.com/input/?i=ExtendedGCD%5B13,15%5D) and solves as 7*13 + (-6)*15 = 1.

Using this with the python code below gives the solution. Note that to raise to a negative power the value needs to be inverted first (i.e. `gmpy.invert`).

```python
import gmpy
import binascii

ct1 = 13981765388145083997703333682243956434148306954774120760845671024723583618341148528952063316653588928138430524040717841543528568326674293677228449651281422762216853098529425814740156575513620513245005576508982103360592761380293006244528169193632346512170599896471850340765607466109228426538780591853882736654
ct2 = 79459949016924442856959059325390894723232586275925931898929445938338123216278271333902062872565058205136627757713051954083968874644581902371182266588247653857616029881453100387797111559677392017415298580136496204898016797180386402171968931958365160589774450964944023720256848731202333789801071962338635072065
e1 = 13
e2 = 15
modulus = 103109065902334620226101162008793963504256027939117020091876799039690801944735604259018655534860183205031069083254290258577291605287053538752280231959857465853228851714786887294961873006234153079187216285516823832102424110934062954272346111907571393964363630079343598511602013316604641904852018969178919051627

# ct1 == plain ** 13 % modulus
# ct2 == plain ** 15 % modulus

pt = pow(ct1,7,modulus) * pow(gmpy.invert(ct2,modulus),6,modulus)
pt = pt % modulus
print(pt)
print(hex(pt))
print(hex(modulus))
print(binascii.unhexlify('%x'%pt))
```

Running this gives the flag in plaintext:

```
$ ./flipping_bits.py 
50937517501984079318479184180525081694999782691988219077509947184814275476037417455150384
0x666c61672d3534643364623563316566636437616661353739633337626362353630616530
0x92d509fe9445e62645936c9ff5f565fa916c2374940a847a192cf444467736cc3ad6dc12f332b13546823e52d692d63fb8c3f56350c685006592152f450eab456d18f54b7b7821dbff65d3a9f7355145609689d66504fd7e75357f086b6ad24bfd475cb8966fb934fb049a83b7dd70ffe3fa87a84aff7d63a76fbd7de1f6a16b
b'flag-54d3db5c1efcd7afa579c37bcb560ae0'
```
